
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <title>Database · My Blog</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.1.4">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-hints/plugin-hints.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="kafka.html" />
    
    
    <link rel="prev" href="big-integer.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    My Blog
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="./">
            
                <a href="./">
            
                    
                    General
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.2.1" data-path="bits-and-bytes.html">
            
                <a href="bits-and-bytes.html">
            
                    
                    Bits & Bytes
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.2" data-path="character-encoding.html">
            
                <a href="character-encoding.html">
            
                    
                    Character Encoding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.3" data-path="nat-and-p2p-traversal.html">
            
                <a href="nat-and-p2p-traversal.html">
            
                    
                    NAT & P2P Traversal
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.4" data-path="api-design-guidelines.html">
            
                <a href="api-design-guidelines.html">
            
                    
                    API Design Guidelines
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.5" data-path="big-integer.html">
            
                <a href="big-integer.html">
            
                    
                    Big Integer
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2.6" data-path="database.html">
            
                <a href="database.html">
            
                    
                    Database
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2.7" data-path="kafka.html">
            
                <a href="kafka.html">
            
                    
                    Kafka
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="../golang/">
            
                <a href="../golang/">
            
                    
                    Golang
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../golang/strings.html">
            
                <a href="../golang/strings.html">
            
                    
                    Strings
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../golang/goroutine.html">
            
                <a href="../golang/goroutine.html">
            
                    
                    Goroutine
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="../rag/">
            
                <a href="../rag/">
            
                    
                    RAG
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="../rag/crawling-result.html">
            
                <a href="../rag/crawling-result.html">
            
                    
                    Crawling Result
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.2" data-path="../rag/chunking.html">
            
                <a href="../rag/chunking.html">
            
                    
                    Chunking
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="../p2p-chat.html">
            
                <a href="../p2p-chat.html">
            
                    
                    P2P Chat
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="../reactjs.html">
            
                <a href="../reactjs.html">
            
                    
                    ReactJS
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7" data-path="../math/">
            
                <a href="../math/">
            
                    
                    Math
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.7.1" data-path="../math/basic.html">
            
                <a href="../math/basic.html">
            
                    
                    Basic
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.2" data-path="../math/problem.html">
            
                <a href="../math/problem.html">
            
                    
                    Problem
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.3" data-path="../math/quadratic-equation.html">
            
                <a href="../math/quadratic-equation.html">
            
                    
                    Quadratic Equation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.7.4" data-path="../math/polynomial.html">
            
                <a href="../math/polynomial.html">
            
                    
                    Polynomial
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.8" data-path="../system-design/template-component-design.html">
            
                <a href="../system-design/template-component-design.html">
            
                    
                    Topic Breakdown
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9" data-path="../system-design/">
            
                <a href="../system-design/">
            
                    
                    System Design
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.9.1" data-path="../system-design/template-high-level-design.html">
            
                <a href="../system-design/template-high-level-design.html">
            
                    
                    [Template] High Level Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.2" data-path="../system-design/consistent-hashing.html">
            
                <a href="../system-design/consistent-hashing.html">
            
                    
                    Consistent Hashing
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.3" data-path="../system-design/id-generator.html">
            
                <a href="../system-design/id-generator.html">
            
                    
                    ID Generator
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.9.4" data-path="../system-design/clock-skew-and-time-sync.html">
            
                <a href="../system-design/clock-skew-and-time-sync.html">
            
                    
                    Clock Skew & Time Sync
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.10" data-path="../saas-ideas.html">
            
                <a href="../saas-ideas.html">
            
                    
                    SaaS Ideas
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >Database</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="database">Database</h1>
<pre><code>Q: What are the ACID properties?
Q: What is the column Cardinality?
Q: How does a Composite Index work, and what is the "Leftmost Prefix" rule?
Q: How do you identify and fix the N+1 Query Problem?
Q: When should you use Normalization (3NF) versus Denormalization
Q: What is Connection Pooling and why is it critical for high-throughput applications?
Q: What is a "Race Condition" in a database context?
Q: What is the difference between Optimistic and Pessimistic Locking, and when should I use which?
Q: What specific data anomalies occur if we choose the wrong locking strategy or isolation level?
Q: Why shouldn't we just use the "Serializable" isolation level for everything to be safe? 
Q: What is the Write-Ahead Log (WAL), and why is it critical for durability?
Q: What is the difference between Synchronous and Asynchronous Replication?
Q: What is the difference between Vertical Scaling (Scaling Up) and Horizontal Scaling (Scaling Out)?
Q: How do "Eventual Consistency" and "Strong Consistency" differ in practice?
Q: How do we handle transactions when data is sharded or split across different services (Microservices)?
</code></pre><h4 id="q-what-are-the-acid-properties"><strong>Q</strong>: What are the ACID properties?</h4>
<p>ACID stands for Atomicity (all-or-nothing execution), \
Consistency (data always follows rules/constraints), \
Isolation (concurrent transactions don't interfere with each other), \
Durability (saved data survives power loss). </p>
<p>In a high-throughput environment, Isolation is the property most frequently "negotiated" or relaxed because perfect isolation (Serializability) is incredibly expensive. To guarantee that every transaction appears to happen one after another, the database must employ aggressive locking or validation, which forces transactions to wait in line. This creates a massive bottleneck that kills performance. Therefore, engineers often deliberately choose weaker isolation levels (like <em>Read Committed</em> or <em>Repeatable Read</em>) to allow higher concurrency and speed, accepting the risk of specific data anomalies (like Phantom Reads) as the "price" for scale.</p>
<hr></hr>
<h4 id="q-what-is-the-cardinality-of-a-column-and-how-does-it-affect-index-effectiveness"><strong>Q</strong>: What is the "Cardinality" of a column, and how does it affect index effectiveness?</h4>
<p>Cardinality refers to the number of <em>unique</em> values contained in a specific column relative to the total number of rows in the table. A column with "High Cardinality" contains mostly unique values (e.g., <code>User_ID</code>, <code>Email</code>, <code>UUID</code>), while a column with "Low Cardinality" contains very few unique values repeated many times (e.g., <code>Gender</code>, <code>Is_Active</code>, <code>Status</code>).</p>
<p>Impact on Index Effectiveness: Cardinality is the primary metric the Database Optimizer uses to decide whether to use an index or ignore it.</p>
<ul>
<li>High Cardinality: Indexes are extremely effective here. The B-Tree structure can rapidly narrow down millions of rows to the specific one you need.</li>
<li>Low Cardinality: Indexes are often ignored. If you index a <code>Status</code> column (Active/Inactive) and query for "Active" users (where 90% of users are active), using the index is actually slower than a full table scan. This is because the database would have to jump back and forth between the index and the table data (random I/O) for 90% of the records. A sequential read of the whole table (Full Table Scan) is much faster in this scenario.</li>
</ul>
<blockquote>
<p>Rule of Thumb: If a query returns more than ~30% of the total rows, the optimizer will likely ignore your index.</p>
</blockquote>
<hr></hr>
<h4 id="q-what-is-the-difference-between-b-tree-and-lsm-tree-log-structured-merge-tree-storage-engines"><strong>Q</strong>: What is the difference between B-Tree and LSM Tree (Log-Structured Merge-tree) storage engines?</h4>
<p>The <strong>B-Tree</strong> (used by MySQL/InnoDB, PostgreSQL) its optimized for read-heavy workloads. It organizes data into fixed-size pages in a balanced tree structure. When you modify data, the engine finds the specific page and updates it in place. If a page is full, it splits, which can cause "write amplification" and random I/O operations. This makes B-Trees incredibly fast for reads (consistent lookup speed) but potentially slower for massive, concurrent write streams.</p>
<p>The <strong>LSM Tree</strong> (used by Cassandra, RocksDB, LevelDB) is optimized for high-throughput write workloads. Instead of updating existing files, it treats storage as append-only. New data is written to a "MemTable" (in RAM) and eventually flushed to an immutable "SSTable" on disk (Sequential I/O). Because data is never overwritten, a single record might exist in multiple files (a delete is just a new entry marking it as deleted). Background processes run "Compaction" to merge these files and discard obsolete data. This makes LSM trees incredibly fast for writes, but reads can be slower because the engine may need to check several files to find the latest version of a key.</p>
<hr></hr>
<h4 id="q-how-does-a-composite-index-work-and-what-is-the-leftmost-prefix-rule"><strong>Q</strong>: How does a Composite Index work, and what is the "Leftmost Prefix" rule?</h4>
<p>A Composite Index is a single index acting on multiple columns, ordered by the sequence in which you define them (e.g., <code>CREATE INDEX idx_name ON Table (A, B, C)</code>). The database sorts the data first by column A; then, <em>only</em> where A is identical, it sorts by B; and <em>only</em> where both A and B are identical, it sorts by C.</p>
<p>The Leftmost Prefix Rule states that the database can only utilize the index if the query search terms follow the index order from left to right without skipping. Using the example <code>(A, B, C)</code>:</p>
<ul>
<li>Querying on A works (the index is sorted by A).</li>
<li>Querying on A and B works.</li>
<li>Querying on B or C alone <em>fails</em> to use the index efficiently because, without knowing A, the values of B are scattered randomly throughout the index structure. It is akin to trying to find everyone named "David" in a phone book without knowing their last name; you would have to read every single entry.</li>
</ul>
<hr></hr>
<h4 id="q-how-do-you-identify-and-fix-the-n1-query-problem"><strong>Q</strong>: How do you identify and fix the N+1 Query Problem?</h4>
<p>The N+1 Query Problem is a performance issue that occurs primarily when using ORMs (like GORM in Go or Hibernate in Java). It happens when code fetches a parent record (1 query) and then iterates through a loop to fetch related child records for <em>each</em> parent (N queries). For example, fetching 100 <code>Users</code> and then executing a new SQL query inside a loop to get the <code>Address</code> for each user results in 101 total database calls. This introduces massive network latency, often killing application performance under load.</p>
<p>How to Identify &amp; Fix:</p>
<ul>
<li>Identify: Look at your database logs or APM tools (like Datadog or New Relic). If you see a waterfall of identical <code>SELECT</code> statements executing milliseconds apart (e.g., <code>SELECT * FROM addresses WHERE user_id = ?</code>), you have an N+1 problem.</li>
<li>The solution is Eager Loading or Batch Fetching. Instead of fetching the child inside the loop, you instruct the database to fetch all required data in a single go (or two optimized queries).<ul>
<li>In SQL, this is done via a <code>JOIN</code>.</li>
<li>In Application Logic (like Go), you fetch the list of User IDs first, and run one query: <code>SELECT * FROM addresses WHERE user_id IN (1, 2, 3...)</code>. Most ORMs support this via methods like <code>.Preload()</code> or <code>.With()</code>.</li>
</ul>
</li>
</ul>
<hr></hr>
<h4 id="q-when-should-you-use-normalization-3nf-versus-denormalization">Q: When should you use Normalization (3NF) versus Denormalization?</h4>
<p><strong>Normalization</strong> (specifically 3rd Normal Form or 3NF) is the standard design strategy for write-heavy applications (OLTP) like banking systems, e-commerce order management, or inventory systems. The primary goal is to reduce data redundancy and ensure data integrity. By breaking data into smaller, related tables, you ensure that every piece of data lives in exactly one place. This eliminates "anomalies"—for example, if you update a customer's address, you only do it in the <code>Users</code> table, not in every single <code>Order</code> they’ve ever placed. You should use 3NF when your priority is data accuracy and optimizing for fast, consistent writes (INSERT/UPDATE/DELETE).</p>
<p><strong>Denormalization</strong>, in contrast, is an optimization technique used primarily for read-heavy workloads or analytics systems (OLAP). It duplicating data across tables to avoid expensive "JOIN" operations during queries. For example, in a high-traffic social media feed, you might store the <code>username</code> directly in the <code>Posts</code> table rather than just the <code>user_id</code>. This means the system can retrieve the post and the author's name in a single lookup without joining the <code>Users</code> table. You should use denormalization when your application suffers from slow read performance due to complex joins and you are willing to accept the trade-off of slower, more complex writes (since you now have to update the username in multiple places if it changes).</p>
<hr></hr>
<h4 id="q-what-is-connection-pooling-and-why-is-it-critical-for-high-throughput-applications">Q: What is Connection Pooling and why is it critical for high-throughput applications?</h4>
<p>Connection Pooling is a mechanism that maintains a cache of open, reusable database connections instead of opening and closing a new connection for every single user request. In a typical flow without pooling, every API call requires the application to:</p>
<ol>
<li>Open a TCP socket (Network 3-way handshake).</li>
<li>Perform a TLS/SSL handshake (Encryption setup).</li>
<li>Authenticate with the database (Password check).</li>
<li>Execute the query.</li>
<li>Close the connection</li>
</ol>
<p>For high-throughput applications, steps 1–3 are incredibly expensive and slow. If you have 10,000 users per second, performing the handshake 10,000 times will overwhelm both your application server and the database CPU, leading to massive latency. Connection pooling solves this by keeping a set of connections "alive." When a request comes in, it "borrows" an existing connection, executes the query, and immediately returns the connection to the pool for the next request to use.</p>
<hr></hr>
<h4 id="q-what-is-a-race-condition-in-a-database-context"><strong>Q</strong>: What is a "Race Condition" in a database context?</h4>
<p>A Race Condition occurs when the final outcome of a process depends on the uncontrollable timing or ordering of concurrent events. For example, imagine two users trying to withdraw $10 from a shared wallet that has $100.</p>
<ol>
<li>User A reads balance: $100.</li>
<li>User B reads balance: $100 (before A saves).</li>
<li>User A calculates $100 - $10 = $90 and saves.</li>
<li>User B calculates $100 - $10 = $90 and saves. The final balance is $90, but it should be $80. The second update "raced" the first and overwrote it, causing a Lost Update anomaly. The system failed because it didn't block User B from reading the stale value while User A was working on it.</li>
</ol>
<hr></hr>
<h4 id="q-what-is-the-difference-between-optimistic-and-pessimistic-locking-and-when-should-i-use-which"><strong>Q</strong>: What is the difference between Optimistic and Pessimistic Locking, and when should I use which?</h4>
<p>Isolation levels control how the DB handles locks implicitly, but sometimes you need explicit control.</p>
<ul>
<li>Pessimistic Locking (<code>SELECT ... FOR UPDATE</code>): You assume a conflict <em>will</em> happen. You lock the row immediately when you read it. No one else can touch it until you commit. Use this for high-contention data (e.g., a central generic wallet).</li>
<li><p>Optimistic Locking: You assume a conflict <em>probably won't</em> happen. You don't lock the row on read. Instead, you read a version number (e.g., <code>version: 1</code>). When updating, you check if the version is still 1. If someone else changed it to 2 in the meantime, your <strong>update fails</strong>, and you retry. Use this for lower contention to avoid blocking database connections.<br></br></p>
<pre><code>value = 100, version = 1

User 1 reads: value = 100, version = 1
User 2 reads: value = 100, version = 1

User 1 tries update:
UPDATE ... WHERE version = 1 → SUCCESS
value = 120 version = 2

User 2 tries update using old version:
UPDATE ... WHERE version = 1 → FAIL (0 rows updated)

User 2 retries by reading latest:
value = 120, version = 2

User 2 recomputes and updates:
UPDATE ... WHERE version = 2 → SUCCESS
value = 150 version = 3
</code></pre>

</li>
</ul>
<hr></hr>
<h4 id="q-how-many-transaction-lock-level-are-there-and-when-to-use-them"><strong>Q</strong>: How many transaction lock level are there and when to use them?</h4>
<p><strong>Read Uncommitted</strong> is the lowest level, where a transaction can read data that has been modified by another transaction but not yet committed. This allows for "<strong>dirty reads</strong>," meaning if the other transaction rolls back, your transaction has processed invalid data. You should use this level only for non-critical logging or analytics tasks where absolute accuracy is less important than raw speed, and where blocking other transactions is unacceptable.</p>
<p><strong>Read Committed</strong> is the most common default level (e.g., in PostgreSQL, Oracle, SQL Server). It guarantees that a transaction can only read data that has been permanently committed. This prevents dirty reads but still allows "non-repeatable reads"—if you query the same row twice in one transaction, the data might change if someone else commits an update in between. You should use this for most standard web applications where you need a balance of strong concurrency and reasonable data integrity.</p>
<p><strong>Repeatable Read</strong> ensures that if you read a row once, you will see the exact same data if you read it again within the same transaction, effectively "locking" that version of the row for your session. This prevents non-repeatable reads but can still allow "phantom reads," where new rows added by others might appear in your range queries. You should use this for reporting dashboards or financial calculations where numbers must remain consistent throughout the duration of operation.</p>
<p><strong>Serializable</strong> is the strictest level. It effectively forces transactions to run as if they were happening one after another, preventing all concurrency anomalies (dirty reads, non-repeatable reads, and phantoms). However, this comes at a massive performance cost due to heavy locking or frequent transaction retries. You should use this only for mission-critical operations where data integrity is non-negotiable, such as preventing double-booking in a reservation system or processing sensitive banking transfers.</p>
<hr></hr>
<h4 id="q-why-shouldnt-we-just-use-the-serializable-isolation-level-for-everything-to-be-safe-"><strong>Q</strong>: Why shouldn't we just use the "Serializable" isolation level for everything to be safe? </h4>
<p>While <code>Serializable</code> guarantees the highest data integrity by strictly ordering transactions (making them appear sequential), it comes with a massive performance penalty. To achieve this, databases often employ aggressive locking or abort transactions frequently due to serialization anomalies. In a high-concurrency Fintech environment (e.g., thousands of payment requests per second), using <code>Serializable</code> acts as a bottleneck, drastically reducing Throughput. We need to choosing the lowest isolation level that still guarantees correctness for your specific use case (e.g., using <code>Read Committed</code> for general browsing but <code>Repeatable Read</code> or explicit locking for ledger updates).</p>
<hr></hr>
<h4 id="q-what-is-the-write-ahead-log-wal-and-why-is-it-critical-for-durability"><strong>Q</strong>: What is the Write-Ahead Log (WAL), and why is it critical for durability?</h4>
<p>The Write-Ahead Log (WAL) is an append-only file where the database records changes (inserts, updates, deletes) <em>before</em> they are written to the actual database data files. When a transaction is committed, the database first writes the details of that transaction to the WAL on the disk. Only after the WAL entry is safely stored does the database acknowledge the transaction as "Success" to the client. The actual data tables (B-Trees/Heaps) are updated later in memory and flushed to disk asynchronously (a process called "checkpointing").</p>
<p>Why it is critical: The WAL ensures Durability (the 'D' in ACID) and performance.</p>
<ol>
<li>Performance: Writing to the main data file requires "Random I/O" (finding the exact spot in the B-Tree on the disk), which is slow. Writing to the WAL is "Sequential I/O" (appending to the end of a file), which is incredibly fast.</li>
<li>Crash Recovery: If the database server loses power immediately after a commit but before the main data files are updated, the data in memory is lost. However, upon restart, the database reads the WAL, "replays" the events recorded there, and restores the database to the consistent state it was in right before the crash.</li>
</ol>
<hr></hr>
<h4 id="q-what-is-the-difference-between-synchronous-and-asynchronous-replication"><strong>Q</strong>: What is the difference between Synchronous and Asynchronous Replication?</h4>
<p>This distinction defines the trade-off between Data Integrity and Performance in a distributed system.</p>
<p><strong>Synchronous Replication</strong>: When the primary node receives a write, it sends the data to the replica node and <em>waits</em> for the replica to acknowledge receipt before telling the client "Success." This guarantees Zero Data Loss (RPO = 0) because the data exists in two places. However, it increases write latency (you must wait for the network round-trip) and reduces availability (if the replica goes down, the primary cannot accept writes).</p>
<p><strong>Asynchronous Replication</strong>: The primary node writes the data locally, immediately tells the client "Success," and then sends the data to the replica in the background. This is much faster and the primary keeps working even if the replica is down. However, if the primary crashes before it forwards the latest data to the replica, that data is permanently lost (Replication Lag).</p>
<hr></hr>
<h4 id="q-what-is-the-difference-between-vertical-scaling-scaling-up-and-horizontal-scaling-scaling-out"><strong>Q</strong>: What is the difference between Vertical Scaling (Scaling Up) and Horizontal Scaling (Scaling Out)?</h4>
<p>Vertical Scaling (Scaling Up) means making a single server stronger by adding more CPU, RAM, or faster storage (e.g., upgrading from an AWS <code>t3.medium</code> to an <code>m5.2xlarge</code>). It is simple because you keep your data in one place, preserving ACID properties easily. However, you cannot buy a bigger computer, because it introduces a Single Point of Failure. </p>
<p>Horizontal Scaling (Scaling Out) means adding <em>more</em> servers (nodes) to handle the load, splitting the data across them (Sharding). This offers infinite scale and high availability (if one node dies, others survive). The trade-off is massive complexity: you lose ACID guarantees across nodes (requiring patterns like Sagas or 2PC) and must manage complex data distribution logic.</p>
<hr></hr>
<h4 id="q-how-do-eventual-consistency-and-strong-consistency-differ-in-practice"><strong>Q</strong>: How do "Eventual Consistency" and "Strong Consistency" differ in practice?</h4>
<p>These concepts describe when a read operation is guaranteed to see the results of a write operation.</p>
<p><strong>Strong Consistency</strong>: This guarantees that once a write is confirmed, <em>any</em> subsequent read from any node will return that new value. However, achieving this requires coordination (locking or synchronous consensus like Paxos/Raft), which increases latency and reduces scalability.</p>
<ul>
<li><em>Use Case:</em> Financial ledgers, inventory counts, or password changes. If you transfer money, the balance must update immediately everywhere.</li>
</ul>
<p><strong>Eventual Consistency</strong>: This guarantees that if no new updates are made, all reads will <em>eventually</em> return the last updated value. However, for a short period (milliseconds to seconds), a user might read stale data. This allows the system to remain highly available and fast, as it doesn't need to block writes while syncing data.</p>
<ul>
<li><em>Use Case:</em> Social media feeds, DNS records, or analytics. If you "Like" a post, it is acceptable if your friend doesn't see that "Like" for 2 seconds.</li>
</ul>
<hr></hr>
<h4 id="q-how-do-we-handle-transactions-when-data-is-sharded-or-split-across-different-services-microservices"><strong>Q</strong>: How do we handle transactions when data is sharded or split across different services (Microservices)?</h4>
<p>Once you move to Sharding or Microservices, you lose the ability to use a single database's ACID properties. If you need to update a <code>Wallet</code> database and a <code>Loan</code> database simultaneously, you face the distributed consistency problem. The traditional solution is Two-Phase Commit (2PC). In 2PC, a coordinator tells all databases to "Prepare" (lock resources and verify they can commit). If everyone says "Yes," the coordinator sends a "Commit" command. The downside is that this is a "blocking" protocol; if the coordinator crashes or the network fails, resources remain locked, freezing the system.</p>
<p>The modern standard for high-volume Fintech systems is the Saga Pattern. Instead of a single ACID transaction, a business process is broken down into a sequence of local transactions. Each step updates its own database and publishes an event to trigger the next step. Crucially, Sagas handle failure through Compensating Transactions. If the "Deduct Money" step succeeds but the "Disburse Loan" step fails, the system triggers a "Refund Money" transaction to undo the first step. This embraces "Eventually Consistency" rather than "Strong Consistency," allowing the system to remain highly available and performant even when parts of the network are slow.</p>
<hr></hr>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="big-integer.html" class="navigation navigation-prev " aria-label="Previous page: Big Integer">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="kafka.html" class="navigation navigation-next " aria-label="Next page: Kafka">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Database","level":"1.2.6","depth":2,"next":{"title":"Kafka","level":"1.2.7","depth":2,"path":"general/kafka.md","ref":"general/kafka.md","articles":[]},"previous":{"title":"Big Integer","level":"1.2.5","depth":2,"path":"general/big-integer.md","ref":"general/big-integer.md","articles":[]},"dir":"ltr"},"config":{"plugins":["hints"],"root":"./","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"hints":{"info":"fa fa-info-circle","tip":"fa fa-mortar-board","danger":"fa fa-exclamation-circle","working":"fa fa-wrench"},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"My Blog","language":"en","gitbook":"*"},"file":{"path":"general/database.md","mtime":"2025-12-06T08:55:36.831Z","type":"markdown"},"gitbook":{"version":"6.1.4","time":"2025-12-06T11:33:05.637Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

